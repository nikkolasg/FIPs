---
fip: "0013"
title: Add ProveCommitSectorAggregated method to reduce on-chain congestion
author: Nicola (@nicola), Add others
discussions-to: https://github.com/filecoin-project/FIPs/issues/50
status: Draft
type: Technical
category: Core
created: 2021-17-02
spec-sections: 
  - section-systems.filecoin_mining.sector.lifecycle

---

## Simple Summary

<!--"If you can't explain it simply, you don't understand it well enough." Provide a simplified and layman-accessible explanation of the FIP.-->
Add a method for a miner to submit several sector prove commit messages in a single one.

## Abstract

<!--A short (~200 word) description of the technical issue being addressed.-->
On-chain proofs scale linearly with network growth. This leads to (1) blockchain
being at capacity most of the time leading to high base fee, (2) chain capacity
is currently limiting network growth.

The miner `ProveCommitSector` method only supports committing a single sector at
a time.  It is both frequently executed and expensive.  This proposal adds a
way for miners to post multiple `ProveCommit`s at once in an aggregated fashion
using a `ProveCommitSectorAggregated`. This method amortize some of the costs
across multiple sectors, removes some redundant but costly checks and
drastically reduces per-sector proof size and verification times taking
advantage of a novel cryptography result.


## Change Motivation

<!--The motivation is critical for FIPs that want to change the Filecoin protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the FIP solves. FIP submissions without sufficient motivation may be rejected outright.-->

The miner `ProveCommitSector` method only supports committing a single sector at
a time.  It's one of the two highest frequency methods observed on the chain at
present (the other being `PreCommitSector`).  High-growth miners commit sectors
at rates exceeding 1 per epoch.  It's also a relatively expensive method, with
multiple internal sends and state loads and stores.

Aggregated proof verification allows for more sector commitments to be proven in
less time which will reduce processing time and therefore gas cost per prove
commit. Verification time and size of an aggregated proof scales logarithmically
with the number of proofs being included.

In addition to this primary optimization, there are several secondary
opportunities for improved processing time and gas cost related to batch
processing many prove commits at once: 
- Using a bitfield to specify sector numbers in the `ProveCommitSector` parameters could reduce message size
- PreCommits loading overhead can be done once per batch
- Power actor claim validation can be done once per batch
- Market actor `ComputeDataCommitment` calls can be batched

Additionally the `ProveCommitSectorAggregated` method can do away with the
temporary storage and cron-batching currently used to verify individual prove
commits. This opens further cost reduction opportunities:
- PreCommit info can be loaded once per prove commit rather than once for recording, and again for batch verifying in call back
- Sectors proven through `ProveCommitSectorAggregated` will not need to be stored and read from the power actors `ProofValidationBatch` map

If miner operators implemented a relatively short aggregation period (a day),
the `ProveCommitAggregated` method has the potential to reduce gas costs for:

- State operations: some of the costs listed above can be amortized across
  multiple sectors
- Proof verification: the gas used for proofs can scale sub-linearly with the
  growth of the network using a novel proof aggregation scheme.

## Specification

<!--The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Filecoin implementations. -->

### Actor changes

Add a new method `ProveCommitSectorAggregated` which supports a miner
prove-committing a number of sectors all at once.  The parameters for this
method are a list of prove-commit infos:

```
type ProveCommitSectorAggregatedParams {
    SectorsNumbers bitfield.BitField
}
```

Semantics will be similar to those of `ProveCommitSector` with the following proposed changes:

- Sectornumber bitfield in place of a single abi.SectorNumber in parameters
- Aggregate proof in place of single porep proof in parameters
- MaxProveCommitSize parameter will change
- Minimum and maximum number of sectors proven will be enforced
- PreCommitInfos read in batch
- SealVerifyInfos constructed in batch
- Market actor ComputeDataCommittment method changed to compute batches of commDs
- Gas cost for verification will be updated and now computed as a function of the number of sectors aggregated
- No storing proof info in power actor for batched verification at the end of the epoch.
  - `ProveCommitSectorAggregated` will call into a new runtime syscall `AggregateVerifySeals` in place of power actor `BatchVerifySeals` call.
  - ConfirmSectorProofsValid logic will be copied over to the second half of `ProveCommitSectorAggregated`.

#### Failure handling

- If any predicate on the parameters fails, the call aborts (no change is persisted).
- If the miner has insufficient balance for all prove-commit pledge, the call aborts.

#### Scale and limits

The number of sectors that may be pre-committed in a single aggregation starts
from 50 (TODO) and a maximum of 819 (TODO)

### Proof scheme changes

Protocol Labs research teams in collaboration with external researchers have
worked on an improvement of the Inner Product Pairing result from [Bunz et
al.](https://eprint.iacr.org/2019/1177.pdf).

In high level, the idea is the following: given some Groth16 proofs, one can
generate a single proof of logarithmic size that these were correctly aggregated.

A major transformation from the paper is that this scheme works in the settings
of Filecoin as-is; there is no need for another curve or trusted setup.
More specifically, it works by re-using Filecoin trusted setup and taking Zcash
trusted setup together to provide the aggregating proving and verifiying key. 

A more detailed technical report on the new constructions can be found here (TODO).

#### Proofs API

##### Aggregation

The proofs aggregation procedure expects the following inputs:

```rust
pub fn aggregate_seal_commit_proofs(
    registered_proof: RegisteredSealProof,
    commit_outputs: &[SealCommitPhase2Output],
) -> Result<AggregateSnarkProof>;
```

The `commit_outputs` are the objects returned from the seal commit phase2 API.  The idea is that multiple sectors have been properly committed, and those outputs are compiled into a list for aggregation at some point later in time.

**Requirements**: The scheme can only aggregate a power of two number of proofs
currently. Although there might be some ways to alleviate that requirement, we
currently pad the number of input proofs to match a power of two. Thanks to the
logarithmic nature of the scheme, performance is still very much acceptable.

##### Verification

The proofs verification procedure expects the following inputs:

```rust
pub fn verify_aggregate_seal_commit_proofs(
    registered_proof: RegisteredSealProof,
    aggregated_proofs_len: usize,
    aggregate_proof_bytes: AggregateSnarkProof,
    commit_inputs: Vec<Vec<Fr>>,
) -> Result<bool>;
```

The `aggregated_proofs_len` argument specifies how many proofs were aggregated at the time of calling `aggregate_seal_commit_proofs`.

The `commit_inputs` above have a specific order to them, which *must* match the order of the `commit_outputs` passed into `aggregate_seal_commit_proofs`, but in a flattened manner.  First, to retrieve the `commit_inputs` for a single sector, you can call this:

```rust
pub fn get_seal_inputs(
    registered_proof: RegisteredSealProof,
    comm_r: Commitment,
    comm_d: Commitment,
    prover_id: ProverId,
    sector_id: SectorId,
    ticket: Ticket,
    seed: Ticket,
) -> Result<Vec<Vec<Fr>>>;
```

As an example, if `aggregate_seal_commit_proofs` is called with the `commit_outputs` of Sector 1 and Sector 2 (where that order is important), we would want to compile the `commit_inputs` for verification as follows (pseudo-code for readability):

```rust
let commit_inputs: Vec<Vec<Fr>> = Vec::new();
commit_inputs.extend(get_seal_inputs(..., sector_one_id, ...));
commit_inputs.extend(get_seal_inputs(..., sector_two_id, ...));
```

What this example code does is flattens all of the individual proof commit inputs into a single list, while properly maintaining the exact ordering matching the `commit_outputs` order going into `aggregate_seal_commit_proofs`.  When compiled like this, the `commit_inputs` will be in the exact format required for the `verify_aggregate_seal_commit_proofs` API call.

In this example, `aggregated_proofs_len` would be `2`.

#### Proofs format 

**Notation**: G_1, G_2, and G_t represents the first, second and target group of
the pairing curve, in this case BLS12-381. Fr represents the scalar field.

**Structure**:A proof can be represented as in the following structure: 
```
struct AggregatedProof {
    // Groth16 part
    com_ab0 (G_t, G_t)
    com_c (G_t, G_t)
    ip_ab G_t
    agg_c G_1
    // TIPP/MIPP part
    nproofs u32
    comms_ab [(G_t,G_t),(G_t,G_t)] // a vector of size ceil(log(nproofs))
    comms_c [(G_t,G_t),(G_t,G_t)] // a vector of size ceil(log(nproofs))
    z_ab [(G_t, G_t)] // a vector of size ceil(log(nproofs))
    z_c [(G_1, G_1)] // a vector of size ceil(log(nproofs))
    final_a G_1
    final_b G_2
    final_c G_1
    final_r Fr,
    final_vkey (G_2, G_2)
    final_wkey (G_1, G_1)
}
```

**Serialization**:
* Fields of the struct are serialized in order using little endian mode.
* The field `nproof` is used to determine the size of the vectors that must be
  read afterwise.
* Fr, G_1 and G_2 are serialized according to the Appendix A in the
  [RFC](https://tools.ietf.org/html/draft-irtf-cfrg-bls-signature-04#appendix-A)
  spec that follows out ZCash definition
* G_t serialized (respectively deserialized) using a compression technique from
  "On Compressible Pairings and Their Computation" by Naehrig et al. You can
  find the reference code on the [RELIC
  library](https://github.com/relic-toolkit/relic/commit/b3d831734d8bf3c531a738b9201603fb51108034#diff-a678346b3ab6e13b60395e116deeae7931b3b738c649e89cc146cbec8d00afbcR109).


## Design Rationale

The existing `ProveCommitSector` method will not become redundant, since
aggregation of smaller batches may not be efficient in terms of gas cost (proofs
too big or too expensive to verify).  The method is left intact to support
smooth operation through the upgrade period.

### Failure handling

Aborting on any precondition failure is chosen for simplicity. 
There is no good reason for submitting an invalid pre-commitment, so this should
never happen for correctly-functioning miners.  Aborting on failure will provide
a clear indication that something is wrong, which might be overlooked by an
operator otherwise.

An alternative could be to allow sectors in the aggregation to succeed or fail independently. 
In this case, the method should return a value indicating which sectors succeeded and which failed.
This would complicate both the actor and node implementations somewhat, though not unduly.

### Scale and limits

The goal of the bound on aggregation size is two fold:
* to limit the impact of potentially mistaken or malicious behaviour.  
* to gradually increase the scalability, to have time to observe how the network
  is growing with this new method.

A miner may submit multiple batches in a single epoch to grow faster.

## Backwards Compatibility

This proposal introduces a new exported miner actor method, and thus changes the
exported method API.  While addition of a method may seem logically backwards
compatible, it is difficult to retain the precise behaviour of an invocation to
the (unallocated) method number before the method existed.  Thus, such changes
must be delivered through a major version upgrade to the actors.

This proposal retains the existing non-batch `ProveCommitSector` method, so
mining operations need not change workflows due to this proposal (but _should_
in order to enjoy the reduced gas costs).

## Test Cases

Test cases will accompany implementation.

## Security Considerations

All significant implementation changes carry risk.

The core cryptographic techniques come from the [Bunz et
al.](https://eprint.iacr.org/2019/1177.pdf) paper from 2019 with strong security
proofs.  Our protocol is a derivation of this paper that is able to use the
already existing powers of tau and with increased performance. The paper is also
accompanied by formal security proofs in the same framework as the original
paper. The trusted setup used is the Filecoin Powers of Tau and the ZCash Powers
of Tau: the full key is generated thanks to this
[tool](https://github.com/nikkolasg/taupipp). The cryptographic implementation
is being audited and report will be made available soon.

## Incentive Considerations

This proposal amortizes per-sector costs for high-growth miners, providing an
economy of scale. This same economy cannot be enjoyed by miners growing more
slowly. 

This may present a minor incentive against splitting a single physical operation
into many miner actors (aka Sybils).

## Product Considerations

This proposal reduces the aggregate cost of committing new sectors to the
Filecoin network. 

This will reduce miner costs overall, as well as reduce contention for chain
transaction bandwidth that can crowd out other messages. It enables to have a
larger emboarding rate for the Filecoin network.

## Implementation

* Cryptographic implementation is currently located on the `feat-ipp2` of the bellperson [repo](https://github.com/filecoin-project/bellperson/tree/feat-ipp2/src/groth16/aggregate)
* Integration between Lotus and crypto-land can be found in [rust-fil-proofs](https://github.com/filecoin-project/rust-fil-proofs/tree/feat-aggregation) and the FFI [here](https://github.com/filecoin-project/filecoin-ffi/blob/feat-aggregation).

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
